#ifndef DEBUG
#define DEBUG false
#endif
#ifndef NTP_H
#define NTP_H

/*
   Ntp.h - Class to add ntp support
*/
#include <NtpClientLib.h>

class NtpClient {
public:
    static NTPSyncEvent_t ntpLastEvent; // Last triggered event
    static bool syncEventTriggered;     // True if a time even has been triggered

    NtpClient();
    void init();
    void ntpSyncEvent(); 
    String status(); 

    static void ntpEvent(NTPSyncEvent_t event) {
	NtpClient::ntpLastEvent       = event;
        NtpClient::syncEventTriggered = true;
    }

private:
    NTPClient *_ntpClient;    
};

bool           NtpClient::syncEventTriggered = false;   
NTPSyncEvent_t NtpClient::ntpLastEvent;

/**
 * Constructor
 */

NtpClient::NtpClient() {
#ifdef WIFIC_H
    int i = 0;

    do {
        delay(500);
        i++;
    } while(Wifi::wifiFirstConnected || i > 10);

    Wifi::wifiFirstConnected = false;
    init();
#endif
}

/**
 * @brief Initiates NTP client
 */
void NtpClient::init() {
    // NTP define events
    NTP.onNTPSyncEvent(NtpClient::ntpEvent); 
    NTP.begin(ntpServer, 1, true);
    NTP.setInterval(ntpint);
}

/**
 * @brief This function is called when an NTP syncronization event is trigered
 */
void NtpClient::ntpSyncEvent() {
/*
    if (syncEventTriggered) {
        if (ntpLastEvent) {
            Serial.print ("Time Sync error: ");

            if (ntpLastEvent == noResponse){
                Serial.println ("NTP server not reachable");
            } else if (ntpLastEvent == invalidAddress) {
                Serial.println ("Invalid NTP server address");
            }    
        } else if (DEBUG) {
                Serial.print("Got NTP time: ");
                Serial.println(NTP.getTimeDateString(NTP.getLastNTPSync()));
        }

        syncEventTriggered = false;
    }
*/  
}

/**
 * @brief Returns uptime information 
 */
String NtpClient::status() {
     return NTP.getTimeDateString() + "  Uptime: " + NTP.getUptimeString() + " Since " + NTP.getTimeDateString(NTP.getFirstSync()).c_str();
}

#endif
